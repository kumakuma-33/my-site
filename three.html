<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Twisting Trunk — three.js</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #86c7ff;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP",
          "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      }
      #hud {
        position: fixed;
        left: 14px;
        top: 14px;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.75);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.08);
        color: #0b2239;
        font-size: 12px;
        line-height: 1.5;
        user-select: none;
      }
      #hud strong {
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div><strong>幹のねじれ上昇</strong>（three.js）</div>
      <div>棒（幹）がねじれながら空へ上昇します</div>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(new THREE.Color(0x86c7ff), 10, 80);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 7.5, 20);
      camera.lookAt(0, 8, 0);

      const ambient = new THREE.AmbientLight(0xffffff, 0.65);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 0.95);
      sun.position.set(8, 16, 10);
      scene.add(sun);

      // Sky gradient: big sphere with shader-like color lerp in fragment.
      const skyGeo = new THREE.SphereGeometry(140, 32, 16);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          top: { value: new THREE.Color(0xa8dcff) },
          bottom: { value: new THREE.Color(0x78c3ff) },
        },
        vertexShader: `
          varying vec3 vPos;
          void main() {
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 top;
          uniform vec3 bottom;
          varying vec3 vPos;
          void main() {
            float t = clamp((vPos.y + 70.0) / 140.0, 0.0, 1.0);
            vec3 col = mix(bottom, top, t);
            gl_FragColor = vec4(col, 1.0);
          }
        `,
      });
      scene.add(new THREE.Mesh(skyGeo, skyMat));

      // Trunk (a "stick" as a tree trunk): cylinder + twist deformation in vertex shader.
      const trunkHeight = 28.0;
      const trunkGeo = new THREE.CylinderGeometry(
        0.85,
        1.25,
        trunkHeight,
        34,
        220,
        true
      );
      trunkGeo.translate(0, trunkHeight / 2, 0); // base at y=0

      const trunkMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uHeight: { value: trunkHeight },
          uTwist: { value: 3.25 },
          uBaseColor: { value: new THREE.Color(0x6b4a2f) },
          uTopColor: { value: new THREE.Color(0x8a5d3a) },
          uLightDir: { value: sun.position.clone().normalize() },
        },
        vertexShader: `
          uniform float uTime;
          uniform float uHeight;
          uniform float uTwist;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          varying float vH;

          mat2 rot(float a) {
            float s = sin(a);
            float c = cos(a);
            return mat2(c, -s, s, c);
          }

          void main() {
            vec3 pos = position;
            float h = clamp(pos.y / uHeight, 0.0, 1.0);
            vH = h;

            // Thin, continuous twist along Y; time adds slow rotation.
            float angle = (h * uTwist + uTime * 0.55);
            pos.xz = rot(angle) * pos.xz;

            // Slight organic wobble (subtle).
            float wob = (sin(uTime * 0.9 + h * 9.0) + sin(uTime * 0.6 + h * 14.0)) * 0.02;
            pos.xz *= (1.0 + wob);

            vec4 worldPos = modelMatrix * vec4(pos, 1.0);
            vPosW = worldPos.xyz;

            // Approx normal by twisting normal too (good enough for this look).
            vec3 n = normal;
            n.xz = rot(angle) * n.xz;
            vNormalW = normalize(mat3(modelMatrix) * n);

            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          uniform vec3 uBaseColor;
          uniform vec3 uTopColor;
          uniform vec3 uLightDir;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          varying float vH;

          float hash21(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
          }

          void main() {
            vec3 N = normalize(vNormalW);
            vec3 L = normalize(uLightDir);
            float ndl = clamp(dot(N, L), 0.0, 1.0);

            // Bark-like banding (very subtle).
            float bands = sin(vPosW.y * 3.5) * 0.04;
            float grain = (hash21(vPosW.xz * 1.6) - 0.5) * 0.06;

            vec3 baseCol = mix(uBaseColor, uTopColor, smoothstep(0.0, 1.0, vH));
            baseCol += (bands + grain);

            float shade = 0.28 + ndl * 0.75;
            gl_FragColor = vec4(baseCol * shade, 1.0);
          }
        `,
        side: THREE.DoubleSide,
      });

      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(0, -8, 0);
      scene.add(trunk);

      // A faint cloud-layer plane for depth.
      const haze = new THREE.Mesh(
        new THREE.PlaneGeometry(160, 160),
        new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.08,
        })
      );
      haze.rotation.x = -Math.PI / 2;
      haze.position.y = 2.2;
      scene.add(haze);

      const clock = new THREE.Clock();
      let riseOffset = 0;

      function animate() {
        const dt = clock.getDelta();
        const t = clock.elapsedTime;

        trunkMat.uniforms.uTime.value = t;

        // Rise slowly; loop.
        riseOffset += dt * 1.25;
        const span = 26;
        const y = -10 + (riseOffset % span);
        trunk.position.y = y;

        // Slight camera drift for life.
        camera.position.x = Math.sin(t * 0.08) * 0.6;
        camera.lookAt(0, 10, 0);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener("resize", onResize, { passive: true });
    </script>
  </body>
</html>

